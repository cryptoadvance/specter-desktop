<!-- This file contains javascript helper functions that also can use jinja -->
<script type="text/javascript">



    /*
        Formats the btc amount as sats. 
        Args:
            value (Union[float, str]): (in BTC) Will convert string to float. 
            enableDigitFormatting (bool, optional): Will group the Satoshis into blocks of 3,
                e.g. 3 123 456, and color the blocks. Defaults to false.
        Returns:
            str: The formatted btc amount as html code.
        */
    function internalFormatBtcAmountAsSats(
        value,
        enableDigitFormatting=false,
    ) {
        const locale = 'en-US';
        if (isNaN(parseFloat(value))){
            return parseFloat(value)        
        }
        var s = (parseFloat(value) * 1e8).toLocaleString(locale, { 
            minimumFractionDigits: 0, 
            maximumFractionDigits: 0 
        });         

        let thousandsSeparator = Number(1000).toLocaleString(locale).charAt(1);
        let decimalSeparator = Number(1.1).toLocaleString(locale).charAt(1);
        
        // combine the thousandsSeparator with the left number to an array
        var array = [];
        for (var i in s){
            var letter = s[i];
            if (letter == thousandsSeparator){
                array[array.length-1] += letter;
            } else {
                array.push(letter);
            }
        }

        if (enableDigitFormatting){
            const l = array.length;
            if (l >= 4){
                var left_index = l >= 6 ? l-6 : 0;
                array[left_index] = `<span class="thousand-digits-in-sats-amount">${array[left_index]}`;
                array[l-4] = `${array[l-4]}</span>`;
            }

            var left_index = l >= 3 ? l-3: 0;
            array[left_index] = `<span class="last-digits-in-sats-amount">${array[left_index]}`;
            array[l-1] = `${array[l-1]}</span>`;
        }

        return array.join('')
    }


    /*
        Formats the btc amount such that it can be right aligned such
        that the decimal separator will be always at the same x position.
        Stripping trailing 0's is done via just making the 0's transparent.
        Args:
            value (Union[float, str]): (in BTC) Will convert string to float.
                The float is expected to be in the unit (L)BTC with 8 relevant digits
            maximumDigitsToStrip (int, optional): No more than maximumDigitsToStrip
                trailing 0's will be stripped. Defaults to 7.
            minimumDigitsToStrip (int, optional): Only strip any trailing 0's if
                there are at least minimumDigitsToStrip. Defaults to 6.
            enableDigitFormatting (bool, optional): Will group the Satoshis into blocks of 3,
                e.g. 0.03 123 456, and color the blocks. Defaults to True.
        Returns:
            str: The formatted btc amount as html code.
        */
    function internalFormatBtcAmount(
        value,
        maximumDigitsToStrip=7,
        minimumDigitsToStrip=6,
        enableDigitFormatting=true,
        hideStripped=false
    ){
        if (isNaN(parseFloat(value))){
            return parseFloat(value)        
        }
       
        const locale = 'en-US';
        var formatted_amount = parseFloat(value).toLocaleString(locale, { 
            minimumFractionDigits: 8, 
            maximumFractionDigits: 8 
        }); 

        var array = Array.from(formatted_amount);
        let thousandsSeparator = Number(1000).toLocaleString(locale).charAt(1);
        let decimalSeparator = Number(1.1).toLocaleString(locale).charAt(1);

        var countDigitsThatCanBeStripped = 0;
        for (var j in array){
            var i = array.length - j - 1;
            if (array[i] == "0"){
                countDigitsThatCanBeStripped += 1;
                continue
            }
            break
        }

        if (countDigitsThatCanBeStripped >= minimumDigitsToStrip){
            // loop through the float number, e.g. 0.03 000 000, from the right and replace 0's or the '.' until you hit anything != 0
            for (var j in array){
                var i = array.length - j - 1;
                if ((array[i] == "0") && (array.length - i <= maximumDigitsToStrip)){
                    array[i] = `<span class="unselectable transparent-text ${hideStripped ? 'hidden' : ''}">${array[i]}</span>`;
                    // since this digit == 0, then continue the loop and check the next digit
                    continue
                }
                // the following if branch is only relevant if last_digits_to_strip == 8, i.e. all digits can be stripped
                else if (formatted_amount[i] == "."){
                    array[i] = `<span class="unselectable transparent-text ${hideStripped ? 'hidden' : ''}">${array[i]}</span>`;
                    // since this character == '.', then the loop must be broken now
                }
                // always break the loop. Only the digit == 0 can prevent this break
                break
            }
        }

        const l = array.length;
        if (enableDigitFormatting){
            array[l-6] = `<span class="thousand-digits-in-btc-amount">${array[l-6]}`;
            array[l-4] = `${array[l-4]}</span>`;
            array[l-3] = `<span class="last-digits-in-btc-amount">${array[l-3]}`;
            array[l-1] = `${array[l-1]}</span>`;
        }

        return array.join('');
    }


    // Puts the price in a "note" span.  preText is separator text 
    function internalFormatPriceAsNote(price, preText=''){
        return `<span class="note">${preText}(${price})</span>`
    }


    // Determines if an unit (e.g. from a tx output) is "BTC", "LBTC", "tBTC", "tLBTC"
    // null or "" will also return true
    function internalUnitLabelIsBitcoin(unit){
        if (!unit){
            return true            
        } 
        unit = unit.toUpperCase();
        return ([null, "", "LBTC", "BTC", "TBTC", "TLBTC"].indexOf(unit) > -1)
    }




    // Formats the network independent units to network dependent units,
    // e.g.: btc -> tBTC,  sat --> tsat ,  btc --> tLBTC, sat --> tLsat 
    function formatUnitLabel(targetUnit='{{ "BTC" if specter.is_liquid else specter.unit }}'){ 
        const convertToSat = targetUnit == 'sat';
        var newLabel = targetUnit;
        if (newLabel == "" || !newLabel){
            newLabel = "BTC"
        }                    
        if (convertToSat) {
            if(newLabel.toUpperCase() == "LBTC"){
                newLabel = "Lsat";
            }
            // Liquid JSON response on testnet is already tLBTC 
            else if (newLabel.toUpperCase() == "tLBTC") {
                newLabel = "tLsat";
            }
            if(newLabel.toUpperCase() == "BTC"){
                newLabel = "sat";
            } 
        } else {
            if (targetUnit.toUpperCase() == "BTC") {
                newLabel = "BTC"
            }
        }

        {% if specter.is_testnet %}
            {% if specter.is_liquid %}
                if (!newLabel.startsWith("L")){
                    newLabel = "L" + newLabel;
                }
            {%endif%}
            if (!newLabel.startsWith("t")){
                newLabel = "t" + newLabel;
            }
        {%endif%}
        
        return newLabel;
    }


    // strips the right end of the text with the pattern
    function rstrip(text, pattern) { 
        return text.replace(new RegExp(pattern + "*$"),''); 
    };



    // Formats the valueInBTC (e.g. from a tx output) to an array
    // e.g. ["0.22569496", "tBTC"]
    // by default targetUnit will be set to BTC for liquid to prevent any conversion of valueInBTC
    function formatBtcAmountAndUnitArray(valueInBTC, targetUnit='{{ "BTC" if specter.is_liquid else specter.unit }}', hideStripped=true){
        if ('{{ specter.hide_sensitive_info }}' == 'True'){
            return ["#########"]};
        if ((valueInBTC < 0 || valueInBTC == null) && '{{ specter.is_liquid }}' == 'True'){
            return ["Confidential"]}
        if (valueInBTC == null){
            return ["Unknown"]};

        const convertToSat = targetUnit == 'sat';
        var formattedUnitLabel = formatUnitLabel(targetUnit);        
        var formattedValue = convertToSat ? internalFormatBtcAmountAsSats(valueInBTC) : internalFormatBtcAmount(
                                                                                            valueInBTC,
                                                                                            7,
                                                                                            6,
                                                                                            true,
                                                                                            hideStripped);
        return [formattedValue, formattedUnitLabel];  
    }

    // Formats the valueInBTC (e.g. from a tx output) to an "formattedValue formattedUnitLabel"
    // e.g. "0.22569496 tBTC"
    function formatBtcAmountAndUnit(valueInBTC, targetUnit='{{ "BTC" if specter.is_liquid else specter.unit }}', hideStripped=true){
        return formatBtcAmountAndUnitArray(valueInBTC, targetUnit, hideStripped).join(' ');  
    }
    // Formats the valueInBTC (e.g. from a tx output) to an "formattedValue"
    // e.g. "0.22569496"
    function formatBtcAmount(valueInBTC, targetUnit='{{ "BTC" if specter.is_liquid else specter.unit }}', hideStripped=true){
        return formatBtcAmountAndUnitArray(valueInBTC, targetUnit, hideStripped)[0];  
    }




    // Calculates and formats the price as a span class="note"
    function formatPrice(valueInBTC, 
                        unit='BTC', 
                        symbol='{{ specter.alt_symbol }}', 
                        price='{{ specter.alt_rate }}',
                        wrapInSpan=true,
                        ){        
        {% if not specter.price_check %}
            return ''
        {% endif %}


        if ('{{ specter.hide_sensitive_info }}' == 'True'){
            return ["#########"]};
        if ((valueInBTC < 0 || valueInBTC == null) && '{{ specter.is_liquid }}' == 'True'){
            return [""]}
        if (valueInBTC == null){
            return [""]};


        var formattedPrice = "";
        if (valueInBTC) {
            if(internalUnitLabelIsBitcoin(unit)){
                if (price && symbol) {
                    const locale = 'en-US';
                    let thousandsSeparator = Number(1000).toLocaleString(locale).charAt(1);
                    let decimalSeparator = Number(1.1).toLocaleString(locale).charAt(1);
                    var formatted_amount = (parseFloat(valueInBTC)*parseFloat(price)).toLocaleString(locale, { 
                        minimumFractionDigits: 2, 
                        maximumFractionDigits: 2 
                    });
                    formatted_amount = rstrip(formatted_amount, '0')
                    formatted_amount = rstrip(formatted_amount, `\\${decimalSeparator}`)
                    formattedPrice = (["$", "£"].includes(symbol)) ? `${symbol}${formatted_amount}` : `${formatted_amount}${symbol}`;
                    formattedPrice = wrapInSpan ? internalFormatPriceAsNote(formattedPrice, ' ') : formattedPrice;
                }
            }
        }
        return formattedPrice
    }



</script>
