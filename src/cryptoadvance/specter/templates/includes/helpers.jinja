<!-- This file contains javascript helper functions that also can use jinja -->
<script type="text/javascript">



    /*
        Formats the btc amount as sats. 
        Args:
            enableDigitFormatting (bool, optional): Will group the Satoshis into blocks of 3,
                e.g. 3 123 456, and color the blocks. Defaults to false.
        Returns:
            str: The formatted btc amount as html code.
        */
    function internalFormatBtcAmountAsSats(
        value,
        enableDigitFormatting=false,
    ) {
        const locale = 'en-US';
        var s = (parseFloat(value) * 1e8).toLocaleString(locale, { 
            minimumFractionDigits: 0, 
            maximumFractionDigits: 0 
        });         

        let thousandsSeparator = Number(1000).toLocaleString(locale).charAt(1);
        let decimalSeparator = Number(1.1).toLocaleString(locale).charAt(1);
        
        // combine the thousandsSeparator with the left number to an array
        var array = [];
        for (var i in s){
            var letter = s[i];
            if (letter == thousandsSeparator){
                array[array.length-1] += letter;
            } else {
                array.push(letter);
            }
        }

        if (enableDigitFormatting){
            const l = array.length;
            if (l >= 4){
                var left_index = l >= 6 ? l-6 : 0;
                array[left_index] = `<span class="thousand-digits-in-sats-amount">${array[left_index]}`;
                array[l-4] = `${array[l-4]}</span>`;
            }

            var left_index = l >= 3 ? l-3: 0;
            array[left_index] = `<span class="last-digits-in-sats-amount">${array[left_index]}`;
            array[l-1] = `${array[l-1]}</span>`;
        }

        return array.join('')
    }


    /*
        Formats the btc amount such that it can be right aligned such
        that the decimal separator will be always at the same x position.
        Stripping trailing 0's is done via just making the 0's transparent.
        Args:
            value (Union[float, str]): Will convert string to float.
                The float is expected to be in the unit (L)BTC with 8 relevant digits
            maximumDigitsToStrip (int, optional): No more than maximumDigitsToStrip
                trailing 0's will be stripped. Defaults to 7.
            minimumDigitsToStrip (int, optional): Only strip any trailing 0's if
                there are at least minimumDigitsToStrip. Defaults to 6.
            enableDigitFormatting (bool, optional): Will group the Satoshis into blocks of 3,
                e.g. 0.03 123 456, and color the blocks. Defaults to True.
        Returns:
            str: The formatted btc amount as html code.
        */
    function internalFormatBtcAmount(
        value,
        maximumDigitsToStrip=7,
        minimumDigitsToStrip=6,
        enableDigitFormatting=true,
        hideStripped=false
    ){
       
        const locale = 'en-US';
        var formatted_amount = parseFloat(value).toLocaleString(locale, { 
            minimumFractionDigits: 8, 
            maximumFractionDigits: 8 
        }); 

        var array = Array.from(formatted_amount);
        let thousandsSeparator = Number(1000).toLocaleString(locale).charAt(1);
        let decimalSeparator = Number(1.1).toLocaleString(locale).charAt(1);

        var countDigitsThatCanBeStripped = 0;
        for (var j in array){
            var i = array.length - j - 1;
            if (array[i] == "0"){
                countDigitsThatCanBeStripped += 1;
                continue
            }
            break
        }

        if (countDigitsThatCanBeStripped >= minimumDigitsToStrip){
            // loop through the float number, e.g. 0.03 000 000, from the right and replace 0's or the '.' until you hit anything != 0
            for (var j in array){
                var i = array.length - j - 1;
                if ((array[i] == "0") && (array.length - i <= maximumDigitsToStrip)){
                    array[i] = `<span class="unselectable transparent-text ${hideStripped ? 'hidden' : ''}">${array[i]}</span>`;
                    // since this digit == 0, then continue the loop and check the next digit
                    continue
                }
                // the following if branch is only relevant if last_digits_to_strip == 8, i.e. all digits can be stripped
                else if (formatted_amount[i] == "."){
                    array[i] = `<span class="unselectable transparent-text ${hideStripped ? 'hidden' : ''}">${array[i]}</span>`;
                    // since this character == '.', then the loop must be broken now
                }
                // always break the loop. Only the digit == 0 can prevent this break
                break
            }
        }

        const l = array.length;
        if (enableDigitFormatting){
            array[l-6] = `<span class="thousand-digits-in-btc-amount">${array[l-6]}`;
            array[l-4] = `${array[l-4]}</span>`;
            array[l-3] = `<span class="last-digits-in-btc-amount">${array[l-3]}`;
            array[l-1] = `${array[l-1]}</span>`;
        }

        return array.join('');
    }


    // Puts the price in a "note" span.  preText is separator text 
    function internalFormatPriceAsNote(price, preText=''){
        return `<span class="note">${preText}(${price})</span>`
    }

    String.prototype.rstrip = function(s) { 
        return this.replace(new RegExp(s + "*$"),''); 
    };


    // Determines if an unitLabel (e.g. from a tx output) is "BTC", "LBTC", "tBTC", "tLBTC"
    function internalUnitLabelIsBitcoin(unitLabel){
        if (!unitLabel){
            return true            
        } 
        unitLabel = unitLabel.toUpperCase();
        return ([null, "", "LBTC", "BTC", "TBTC", "TLBTC"].indexOf(unitLabel) > -1)
    }




    // Formats the network independent units to network dependent units,
    // e.g.: btc -> tBTC,  sat --> tsat ,  btc --> tLBTC, sat --> tLsat 
    function formatUnitLabel(unitLabel='{{ specter.unit }}'){ 
        const convertToSat = unitLabel == 'sat';
        var newLabel = unitLabel;
        if (newLabel == "" || !newLabel){
            newLabel = "BTC"
        }                    
        if (convertToSat) {
            if(newLabel == "LBTC"){
                newLabel = "Lsat";
            }
            // Liquid JSON response on testnet is already tLBTC 
            else if (newLabel == "tLBTC") {
                newLabel = "tLsat";
            }
            if(newLabel == "BTC"){
                newLabel = "sat";
            } 
        } else {
            if (unitLabel == "btc") {
                newLabel = "BTC"
            }
        }

        {% if specter.is_testnet %}
            {% if specter.is_liquid %}
                if (!newLabel.startsWith("L")){
                    newLabel = "L" + newLabel;
                }
            {%endif%}
            if (!newLabel.startsWith("t")){
                newLabel = "t" + newLabel;
            }
        {%endif%}
        
        return newLabel;
    }





    // Formats the valueInBTC (e.g. from a tx output) to an array
    // e.g. ["0.22569496", "tBTC"]
    function formatBtcAmountAndUnitArray(valueInBTC, unitLabel='{{ specter.unit }}', hideStripped=true){
        if ('{{ specter.hide_sensitive_info }}' == 'True'){
            return ["#########"]};
        if (valueInBTC == null){
            return ["Unknown"]};
        if (valueInBTC <= 1e-8 && '{{ specter.is_liquid }}' == 'True'){
            return ["Confidential"]}

        const convertToSat = unitLabel == 'sat';
        var formattedUnitLabel = formatUnitLabel(unitLabel);        
        var formattedValue = convertToSat ? internalFormatBtcAmountAsSats(valueInBTC) : internalFormatBtcAmount(
                                                                                            valueInBTC,
                                                                                            7,
                                                                                            6,
                                                                                            true,
                                                                                            hideStripped);
        return [formattedValue, formattedUnitLabel];  
    }

    // Formats the valueInBTC (e.g. from a tx output) to an "formattedValue formattedUnitLabel"
    // e.g. "0.22569496 tBTC"
    function formatBtcAmountAndUnit(valueInBTC, unitLabel='{{ specter.unit }}', hideStripped=true){
        return formatBtcAmountAndUnitArray(valueInBTC, unitLabel, hideStripped).join(' ');  
    }
    // Formats the valueInBTC (e.g. from a tx output) to an "formattedValue"
    // e.g. "0.22569496"
    function formatBtcAmount(valueInBTC, unitLabel='{{ specter.unit }}', hideStripped=true){
        return formatBtcAmountAndUnitArray(valueInBTC, unitLabel, hideStripped)[0];  
    }




    // Calculates and formats the price as a span class="note"
    function formatPrice(valueInBTC, 
                        unitLabel='{{ specter.unit }}', 
                        symbol='{{ specter.alt_symbol }}', 
                        price='{{ specter.alt_rate }}',
                        wrapInSpan=true,
                        ){
        {% if not specter.price_check %}
            return ''
        {% endif %}

        if ('{{ specter.hide_sensitive_info }}' == 'True'){
            return "#########"};
        if (valueInBTC == null){
            return "Can't be calculated"};
        if (valueInBTC < 0){
            return "-"}

        var formattedPrice = "";
        if (valueInBTC) {
            if(internalUnitLabelIsBitcoin(unitLabel)){
                if (price && symbol) {
                    const locale = 'en-US';
                    let thousandsSeparator = Number(1000).toLocaleString(locale).charAt(1);
                    let decimalSeparator = Number(1.1).toLocaleString(locale).charAt(1);
                    var formatted_amount = (parseFloat(valueInBTC)*parseFloat(price)).toLocaleString(locale, { 
                        minimumFractionDigits: 2, 
                        maximumFractionDigits: 2 
                    }).rstrip('0').rstrip(`\\${decimalSeparator}`); 

                    formattedPrice = (symbol in ["$", "£"]) ? `${symbol}${formatted_amount}` : `${formatted_amount}${symbol}`;
                    formattedPrice = wrapInSpan ? internalFormatPriceAsNote(formattedPrice, ' ') : formattedPrice;
                }
            }
        }
        return formattedPrice
    }



</script>
