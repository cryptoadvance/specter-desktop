<!-- 
    A recipient form that returns a Jsonified dictionary of address, label and amount

{#- Usage -

    <recipient-box
    >
    </recipient-box>

#} 
-->

<template id="recipient-box">

	<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='styles.css') }}">
	<style>
		:host {
			display: block;
			width: 100%;
		}

		#textarea-content {
			height: 150px;
			font-size: 13px;
		}
	</style>

	<textarea id="textarea-content" placeholder="{{ _('You can drag & drop here.') }}"></textarea>
	<input type="text" id="address" name="address" placeholder='{{ _("Recipient address") }}'>


</template>


<script type="text/javascript">
	class RecipientBox extends HTMLElement {
		// This tells the browser to treat the element like a form control
		static formAssociated = true;
		// For details on how to ensure that a custom element gets picked up by a parent <form> see:
		// https://web.dev/more-capable-form-controls/#defining-a-form-associated-custom-element
		// see https://css-tricks.com/creating-custom-form-controls-with-elementinternals/ 
		static formAssociated = true;

		static get styles() {
			return css `
			:host {
				display: block;
				width: 100%;
			}
			#textarea-content { 
				height: 150px; 
				font-size: 13px;
			}
			`;
		}



		constructor() {
			super();
			this.internals = this.attachInternals();
			// Create a shadow root
			let shadowRoot = this.attachShadow({
				mode: 'open'
			});

			shadowRoot.innerHTML = ` 
				<input type="text"  id="line1"    placeholder='1'>
				<input type="text"  id="line2"    placeholder='1'> `;


			this.inputs = {};

			this.ids = [ "line1", "line2",  ];
			for (var i in this.ids)	{
				var id = this.ids[i];
				var element = this.shadowRoot.getElementById(id);
				if (element){
					this.inputs[id] = element;
				}
			}
			console.log(this.inputs)


			this.internals.setFormValue(this.value);
		}


		static get observedAttributes() {
			var attributes = ["value" ];
			for (var i in this.ids)	{
				var id = this.ids[i];
				attributes.push(id);
			}			
			return attributes;
		}



		connectedCallback() {
			this.inputs['line1'].addEventListener("change", (event) => {
				this.internals.setFormValue(this.value);
				console.log(this.value);
			})
			this.inputs['line2'].addEventListener("change", (event) => {
				this.internals.setFormValue(this.value);
				console.log(this.value);
			})
		}

		disconnectedCallback() {
			this.inputs['line1'].removeEventListener('change');
			this.inputs['line2'].removeEventListener('change');
		}




		setFormValue(){
			this.internals.setFormValue(this.value);
		}

		attributeChangedCallback(attribute, oldValue, newValue) {
			switch (attribute) {
				case "value":
					setValue(newValue);
					break;
				case "line1":
					this.inputs['line1'].value = newValue;
					setFormValue();
					break;
				case "line2":
					this.inputs['line2'].value = newValue;
					setFormValue();
					break;					
			}
		}

		// This is essential to make the recipient-box compatible with setting a new value
		set value(newValue) {
			this.setValue(newValue);
		}
		setValue(newValue) {
			var dict = JSON.parse(newValue); 
			this.inputs['line1'].value = dict['line1'];
			this.inputs['line2'].value = dict['line2'];
			setFormValue();
		}
		get value() {
			return JSON.stringify({
				line1: this.inputs['line1'].value,
				line2: this.inputs['line2'].value,
			});
		}

		static get properties() {
			return {
				value: { type: String }
			};
		}

		
	}
	customElements.define('recipient-box', RecipientBox);




</script>