<template id="quote">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='styles.css') }}">

    <h1 class="padded">Trade</h1>
    <p class="center">Available Funds:<br>
        <span class="buyWithAsset">GOLD</span> Balance: <span class="buyWithBalance">0.00000000</span><br>
        <span class="buyAsset">BTC</span> Balance: <span class="buyBalance">0.00000000</span><br>
    </p>
    <div class="card" style="width: 610px; padding-top: 25px;">
        <div class="errorMessagesDiv">
            <message-box type="error" style="display: none;"></message-box>
        </div>


        <h3 class="center">This is using Vaultoro Direct Beta!</h3>
        <p class="center">Vaultoro direct is an easy OTC (over the counter) solution to buying and selling assets on Vaultoro directly with us.</p><br>
        <br>
        <div class="prepTradeDiv">
            Buy Asset:<br>
            <div class="row">
                <select class="buySelect"t>
                    <option value="gold">Gold</option>
                    <option value="silver">Silver</option>
                    <option value="bitcoin">Bitcoin</option>
                </select>
            </div>
            <br>
            With this Asset:<br>
            <div class="row">
                <select class="withSelect"t>
                    <option value="bitcoin">Bitcoin</option>
                </select>
            </div>
            <br>
            Amount to trade (<span class="amountDescription">The amount of gold you want to buy</span>)<br>
            <div class="row">
                <input type="text" class="amount"/><span class></span>&nbsp;&nbsp;
                <button class="switchAmountUnitBtn btn">
                    <svg width=20 viewBox="0 0 504 504"><path stroke="white" fill="white" d="M0 168v-16c0-13.255 10.745-24 24-24h360V80c0-21.367 25.899-32.042 40.971-16.971l80 80c9.372 9.373 9.372 24.569 0 33.941l-80 80C409.956 271.982 384 261.456 384 240v-48H24c-13.255 0-24-10.745-24-24zm488 152H128v-48c0-21.314-25.862-32.08-40.971-16.971l-80 80c-9.372 9.373-9.372 24.569 0 33.941l80 80C102.057 463.997 128 453.437 128 432v-48h360c13.255 0 24-10.745 24-24v-16c0-13.255-10.745-24-24-24z"/></svg>
                </button>
            </div>
            <br>
            <button class="previewTradeBtn btn">Preview Trade</button>
        </div>
        <div class="previewTradeDiv hidden">
            <h3>You buy:</h2>
            <h1>
                <span data-bind="preparedTrade.buyAsset.amount">waiting ...</span>
                <span data-bind="preparedTrade.buyAsset.unit"></span>
                <span data-bind="preparedTrade.buyAsset.name"></span>
            </h1>
            <h3>You pay:</h2>
            <h1>
                <span data-bind="preparedTrade.buyWithAsset.amount">waiting ...</span>
                <span data-bind="preparedTrade.buyWithAsset.unit"></span>
                <span data-bind="preparedTrade.buyWithAsset.name"></span>
            </h1>
            <div class="row">
                <button class="confirmTradeBtn btn" style="margin: 8px;">Confirm Trade</button>
                <button class="cancelTradeBtn btn" style="margin: 8px;">Cancel</button>
            </div>
        </div>
        <div class="successTradeDiv center card hidden">
            <h1>Order completed successfully! &#x1F389;</h1>
            <h2><span data-bind="executedTrade.buyWithAsset.amount"></span> <span data-bind="preparedTrade.buyWithAsset.unit"></span> <span data-bind="preparedTrade.buyWithAsset.name"></span> -> <span data-bind="executedTrade.buyAsset.amount"></span> <span data-bind="preparedTrade.buyAsset.unit"></span> <span data-bind="preparedTrade.buyAsset.name"></span></h2>
            <br>
            <button type="button" class="btn centered" onclick="location.reload();">Continue</button>
        </div>
        <br><p>Min Trade <span class="minTrade">(GOLD): 0.005</span>kg</p><br>
        <svg  version="1.1"  preserveAspectRatio="none" style="width:24px; height:24px;">
            <circle cx="12" cy="12" r="10" class="loader-ring" fill="none" 
                stroke="white" stroke-width="2" stroke-dasharray=",20000" transform="rotate(0,100,100)" />
        </svg>

        <span class="ticker">Gold/BTC: 0.00</span>(kg)
        <br><br>
        <div class="debugArea">
            <hr>
            <h4>Debug Area</h4>

            <h5>Balances</h5>
            {{balances}}
            <h5>quote</h5>
            <pre class="quote"></pre>
            <h5>order</h5>
            <pre class="order"></pre>
            <h5>bindexample</h5>
            <p class="bindexample" data-bind="preparedTrade"></p>
        </div>
    </div>
    <br><br>
</template>

<script type="module" type="text/javascript">
    /*
     * check https://medium.com/swlh/https-medium-com-drmoerkerke-data-binding-for-web-components-in-just-a-few-lines-of-code-33f0a46943b3
     * for infos about CustomElement
     */
    import {CustomElement} from 'static/CustomElement.js';
    /**

      * This custome Element used a state which might look like this, when
      * it's completely populated (which is probably never the case:
      * {
          'preparedTrade': 
            {"createdAt":1611676535,"expires":1611676595,"pair":"GOLDBTC",
             "price":"0.00196304","quantity":"1.00000000",
             "total":"0.00196304","type":"BUY"},
        }
    */
    class VaultoroDirectBuyElement extends CustomElement {
        constructor() {
            super();
            // Create a shadow root
            var shadow = this.attachShadow({mode: 'open'});
            var style = document.getElementById('quote').content;
            var clone = style.cloneNode(true);
    
            // ErrorMessages
            this.errorMessagesDiv = clone.querySelector(".errorMessagesDiv");

            // Prepare the trade (choose assets / amount etc)
            this.prepTradeDiv = clone.querySelector(".prepTradeDiv");

            this.buySelect = clone.querySelector(".buySelect");
            this.buySelect.onchange = () => {
                this.buySelectUpdated()
            }

            this.withSelect = clone.querySelector(".withSelect");
            this.withSelect.onchange = () => {
                this.withSelectUpdated()
            }

            this.amountDescription = clone.querySelector(".amountDescription");

            this.minTrade = clone.querySelector(".minTrade");

            this.amountInput = clone.querySelector(".amount");
            this.amountInput.onchange = () => {
                this.amountInputUpdated()
            }

            this.switchAmountUnitBtn = clone.querySelector(".switchAmountUnitBtn");
            this.switchAmountUnitBtn.onclick = () => {
                this.switchAmountUnitBtnClicked()
            }

            this.previewTradeBtn = clone.querySelector(".previewTradeBtn");
            this.previewTradeBtn.onclick = () => {
                this.previewTradeBtnClicked()
            }

            

            // Preview the prepared Trade
            this.previewTradeDiv = clone.querySelector(".previewTradeDiv");
            
            this.confirmTradeBtn = clone.querySelector(".confirmTradeBtn");
            this.confirmTradeBtn.onclick = () => {
                this.confirmTradeBtnClicked()
            }

            this.cancelTradeBtn = clone.querySelector(".cancelTradeBtn");
            this.cancelTradeBtn.onclick = () => {
                this.cancelTradeBtnClicked()
            }

            this.buyWithAssetSpan = clone.querySelector(".buyWithAsset")
            this.buyAssetSpan = clone.querySelector(".buyAsset")

            this.buyBalance = clone.querySelector(".buyBalance");
            this.buyWithBalance = clone.querySelector(".buyWithBalance");

            // See trade executed successfully data
            this.successTradeDiv = clone.querySelector(".successTradeDiv");

            
            // Data
            this.balances= JSON.parse('{{balances|tojson}}')
            this.setState({amountAsset: this.buySelect.value})
            this.ticker=undefined // get filled with {"ask":"0.00178295","bid":"0.00178703","handle":"GOLDBTC"}}

            // counting towards the next time we'll grab the tickerprice
            this.initCircleTimer(clone)
            this.angle = 60

            this.tickerSpan = clone.querySelector(".ticker")

            // Debug Area
            this.quote = clone.querySelector(".quote");
            this.order = clone.querySelector(".order");

            // Attach the created element to the shadow dom
            shadow.appendChild(clone);
            this.updateBalanceList()
        }

        /*
         * ----==== Events ====----
         */

        
        initCircleTimer(clone) {
            var circle = clone.querySelector('.loader-ring');
            var interval = 300;
            this.angle = 0; // between 0 and 60 , updatable from outside
            var angle_increment = 1;
            window.timer = window.setInterval(function() {
                circle.setAttribute("stroke-dasharray", this.angle + ", 20000");
                if (this.angle >= 60) {
                    this.angle=0
                    try {
                        updateTicker(this, this.getTickerAndType().ticker)
                    } catch (e) {
                        this.handleError(e)
                    }
              }
              this.angle += angle_increment;
            }.bind(this), interval);
        }



        /**
        * triggered when the buy-selector gets updated. Needs to:
        * populate the with-select
        * update the amountinput-Description ("The amount of gold you want to buy")
        * update the balance-list
        */
        buySelectUpdated() {
            while (this.withSelect.options.length) {
                this.withSelect.remove(0);
            }

            switch (this.buySelect.value) {
                case "gold":
                case "silver":
                    var option = document.createElement("option");
                    option.value="bitcoin"
                    option.text = "Bitcoin";
                    this.withSelect.add(option)
                    break;
                case "bitcoin":
                    var option = document.createElement("option");
                    option.value="gold"
                    option.text = "Gold";
                    this.withSelect.add(option)
                    var option = document.createElement("option");
                    option.value="silver"
                    option.text = "Silver";
                    this.withSelect.add(option)
                    break;

            }
            this.setState({amountAsset: this.buySelect.value})
            this.updateAmountDescription()
            this.updateBalanceList()
            // trigger ticker-update
            this.angle = 60 
        }

        /**
        * triggered when the with-selector gets updated. Needs to:
        * update the balance-list (Maybe swopping the order)
        * update the amountinput-Description ("The amount of gold you want to buy")
        */
        withSelectUpdated() {
            this.updateBalanceList()
            this.updateAmountDescription()
            // trigger ticker-update
            this.angle = 60 
        }

        switchAmountUnitBtnClicked() {
            if (this.state.amountAsset==this.buySelect.value) {
                this.setState({amountAsset: this.withSelect.value})
                if (this.buySelect.value == "bitcoin") {
                    this.amountInput.value = this.amountInput.value / (this.ticker["bid"] * 1000 )
                } else {
                    this.amountInput.value = this.amountInput.value * (this.ticker["bid"] * 1000 )
                }
                
            } else {
                this.setState({amountAsset: this.buySelect.value})
                if (this.buySelect.value == "bitcoin") {
                    this.amountInput.value = this.amountInput.value * this.ticker["bid"] / 1000
                } else {
                    this.amountInput.value = this.amountInput.value / this.ticker["bid"] / 1000
                }
            }
            this.updateAmountDescription()
        }

        previewTradeBtnClicked() {
            var preparedTrade
            if (isNaN(parseFloat((this.amountInput.value)))) {
                this.handleError("Please specify a valid Number")
                return
            }
            
            const tickerType = this.getTickerAndType()
            var total = null
            var quantity = null
            if (this.state.amountAsset=="bitcoin") {
                total = this.amountInput.value
            } else {
                quantity = this.amountInput.value * 1000
            }
            console.log("fetch quote for quantity " + quantity + " and type "+tickerType.type)
            // fetchQuote will call processQuoteResponse ...
            preparedTrade = fetchQuote(this, tickerType.ticker, tickerType.type, total, quantity)          

            // ... which will setState but still the UI:
            this.prepTradeDiv.style.display = 'none'
            this.previewTradeDiv.style.display = 'block'
        }

        confirmTradeBtnClicked() {
            execTrade(
                this,
                this.state.preparedTrade.response.pair,
                this.state.preparedTrade.response.type,
                this.state.preparedTrade.response.total,
                this.state.preparedTrade.response.quantity
            )
        }

        cancelTradeBtnClicked() {
            this.prepTradeDiv.style.display = 'block'
            this.previewTradeDiv.style.display = 'none'
            this.setState({preparedTrade: { response: null}})
            this.setState({preparedTrade: { buyAsset: { amount: "waiting ..." } }})
            this.setState({preparedTrade: { buyWithAsset: { amount: "waiting ..."} }})
            this.setState({preparedTrade: { buyAsset: { unit: ""} }})
            this.setState({preparedTrade: { buyWithAsset: { unit: ""} }})
            this.setState({preparedTrade: { buyAsset: { name : ""} }})
            this.setState({preparedTrade: { buyWithAsset: { name : ""} }})
        }

        amountInputUpdated() {
            //Some Validation here
            // e.g. check for min amount
        }

         /*
         * ----==== END OF Events ====----
         */

        handleError(errorText) {
            console.log(errorText)
            const messageBox = document.createElement('message-box');
            messageBox.setType("error")
            messageBox.textContent = errorText
            this.errorMessagesDiv.appendChild(messageBox)
        }

        updateAmountDescription() {
            if (this.state.amountAsset==this.buySelect.value) {
                this.amountDescription.textContent = "The amount of "+this.buySelect.value+ " you want to buy"
            } else {
                this.amountDescription.textContent = "The amount of "+this.withSelect.value+ " you want to spend on "+this.buySelect.value 
            }
        }

        updateBalanceList() {
            let buySelectValue = this.balanceKeyMapping(this.buySelect.value)
            let withSelectValue = this.balanceKeyMapping(this.withSelect.value)
            // Update the desc/labels
            this.buyAssetSpan.textContent = buySelectValue
            this.buyWithAssetSpan.textContent = withSelectValue
            
            // update the amounts
            this.buyBalance.textContent = (this.balances.find(el => el.type="SETTLED" && el.handle==buySelectValue.toUpperCase()).quantity / (buySelectValue.toUpperCase() == "BTC" ? 1 : 1000)).toFixed(8)
            if (this.buyBalance.textContent == '-0.00000000') {
                this.buyBalance.textContent = '0.00000000';
            }
            this.buyWithBalance.textContent = (this.balances.find(el => el.type="SETTLED" && el.handle==withSelectValue.toUpperCase()).quantity / (withSelectValue.toUpperCase() == "BTC" ? 1 : 1000)).toFixed(8)
            if (this.buyWithBalance.textContent == '-0.00000000') {
                this.buyWithBalance.textContent = '0.00000000';
            }

            this.minTrade.textContent = buySelectValue == "GOLD" || withSelectValue == "GOLD" ? "(GOLD) 0.005" : "(SILV) 0.1";
        }

        balanceKeyMapping(asset) {
            switch (asset.toUpperCase()) {
                case "GOLD":
                    return "GOLD"
                case "SILVER":
                    return "SILV"
                case "BITCOIN":
                    return "BTC"
            }
            return null
        }

        /**
         * Depending on the values of the select-fields, it's return one of these
         * ticker-symbols:
         * - GOLDBTC
         * - SILVBTC
         */
        getTickerAndType() {
            if (this.buySelect.value == "gold") {
                return {ticker:"GOLDBTC" , type:"BUY"}
            } else if (this.buySelect.value == "silver") {
                return {ticker:"SILVBTC", type:"BUY"}
            } else if (this.buySelect.value == "bitcoin") {
                if (this.withSelect.value == "gold") {
                    return {ticker:"GOLDBTC" , type:"SELL"}
                } else {
                    return {ticker:"SILVBTC" , type:"SELL"}
                }
            }
            throw `Couldn't find correct values for buySelect ${this.buySelect.value} and withSelect ${this.withSelect.value}`
        }

        getUnit(asset) {
            switch (asset.toUpperCase()) {
                case "GOLD":
                    return "g"
                case "SILVER":
                    return "g"
                case "BITCOIN":
                    return ""
            }
            throw "unknown asset"+asset
        }

        /**
         * callback get called from fetchQuote in order to transform the response
         * to a reasonable this.state
         */
        processQuoteResponse(resp) {
            // Not so nice, would love if that would work in one go but then the binding
            // no longer works
            // self.setState({preparedTrade: {response: jsonResponse}  })
            // we probably not even need all of them here
            this.setState({preparedTrade: { response: resp}})
            // this.state.preparedTrade.(buyAsset|buyWithAsset) is for the ui
            // Relevant later to confirm the trade is only state.preparedTrade.response
            switch (resp.pair+" "+resp.type) {
                case "GOLDBTC BUY":
                    this.setState({preparedTrade: {buyAsset: { name: "Gold"}}})
                    this.setState({preparedTrade: {buyAsset: { amount: resp.quantity/1000}}})
                    this.setState({preparedTrade: {buyAsset: { unit: "kg"}}})
                    this.setState({preparedTrade: {buyWithAsset: { name : "BTC"}}})
                    this.setState({preparedTrade: {buyWithAsset: { unit: ""}}})
                    this.setState({preparedTrade: {buyWithAsset: { amount : resp.total}}})
                    break;
                case "GOLDBTC SELL":
                    this.setState({preparedTrade: {buyAsset: { name: "BTC"}}})
                    this.setState({preparedTrade: {buyAsset: { amount: resp.total}}})
                    this.setState({preparedTrade: {buyAsset: { unit: ""}}})
                    this.setState({preparedTrade: {buyWithAsset: { name : "Gold"}}})
                    this.setState({preparedTrade: {buyWithAsset: { unit: "kg"}}})
                    this.setState({preparedTrade: {buyWithAsset: { amount : resp.quantity/1000}}})
                    break;
                case "SILVBTC BUY":
                    this.setState({preparedTrade: {buyAsset: { name: "Silver"}}})
                    this.setState({preparedTrade: {buyAsset: { amount: resp.quantity/1000}}})
                    this.setState({preparedTrade: {buyAsset: { unit: "kg"}}})
                    this.setState({preparedTrade: {buyWithAsset: { name : "BTC"}}})
                    this.setState({preparedTrade: {buyWithAsset: { unit: ""}}})
                    this.setState({preparedTrade: {buyWithAsset: { amount : resp.total}}})
                    break;
                case "SILVBTC SELL":
                    this.setState({preparedTrade: {buyAsset: { name: "BTC"}}})
                    this.setState({preparedTrade: {buyAsset: { amount: resp.total}}})
                    this.setState({preparedTrade: {buyAsset: { unit: ""}}})
                    this.setState({preparedTrade: {buyWithAsset: { name : "Silver"}}})
                    this.setState({preparedTrade: {buyWithAsset: { unit: "kg"}}})
                    this.setState({preparedTrade: {buyWithAsset: { amount : resp.quantity/1000}}})
                    break;
                default:
                    throw "couldn't find reasonable data from response"+resp
            }
        }
    }

    /* Async function using self as a poor-man's "this"
        Fetches the ticker from vaultoro and updates the UI
    */
    async function updateTicker(self, ticker) {
        try {
            const params = new URLSearchParams({
                "pair": ticker
            })
            let url = `{{vaultoro_url}}/public/ticker?${params.toString()}`;
            const response = await fetch(
                url,
                {
                    method: 'GET'
                }
            )
            const jsonResponse = await response.json();
            if (jsonResponse["data"] == undefined) {
                self.handleError(`api endpoint ${url} is not returning expected data but: ${JSON.stringify(jsonResponse)}`)
                return
            }
            self.ticker = jsonResponse["data"]
            self.tickerSpan.textContent = `${self.buySelect.value}/${self.withSelect.value} ${self.ticker["bid"]*1000} `
        } catch(e) {
            self.handleError(e);
        }
    }

    async function fetchQuote(self, pair, type, total, quantity) {
        var url = 'api/buy/quote'
        console.log(`Calling fetchQuote pair: ${pair} total/quantity: ${total} / ${quantity} type: ${type}`) 

        try {
            const response = await fetch(
                url,
                {
                    method: 'POST',
                    headers:{
                        "Content-type":"application/json"
                    },
                    body: JSON.stringify({
                        "type": type,
                        "pair":pair,
                        "total": parseFloat(total),
                        "quantity": parseFloat(quantity)
                    })
                }
            )
            // Here is how a typical response looks like:
            // {"createdAt":1611739612,"expires":1611739672,"pair":"GOLDBTC",
            //  "price":"0.00200066","quantity":"1000.00000000","total":"2.00066000","type":"BUY"}
            const jsonResponse = await response.json();
            self.quote.innerText = JSON.stringify(jsonResponse)
            
            self.processQuoteResponse(jsonResponse)
        } catch(e) {
            self.handleError(e);
        }
    }

    async function execTrade(self, pair, type, total, quantity) {
        var url = 'svc/vaultoro/api/buy/order'
        console.log(`Calling execTrade pair: ${pair} type: ${type} total/quantity: ${total} / ${quantity} type: ${type}`) 
        try {
            const response = await fetch(
                url,
                {
                    method: 'POST',
                    headers:{
                        "Content-type":"application/json"
                    },
                    body: JSON.stringify({
                        "type": type,
                        "pair":pair,
                        "quantity": parseFloat(quantity),
                        "total": parseFloat(total)
                    })
                }
            )
            const jsonResponse = await response.json();
            self.order.innerText = JSON.stringify(jsonResponse);
            if (jsonResponse.errors) {
                showError(jsonResponse.errors.replace("got 422 and error ['", '').replace("']", ''));
            } else {
                console.log(jsonResponse);
                self.previewTradeDiv.style.display = 'none';
                self.successTradeDiv.style.display = 'block';
                self.setState({executedTrade: { buyAsset: { amount: jsonResponse.result.type == "BUY" ? jsonResponse.result.quantity / 1000 : jsonResponse.result.total } }});
                self.setState({executedTrade: { buyWithAsset: { amount: jsonResponse.result.type == "SELL" ? jsonResponse.result.quantity / 1000 : jsonResponse.result.total } }});
                self.setState({executedTrade: { price: jsonResponse.result.price }});
                showNotification('Trade executed successfully!');
            }
        } catch(e) {
            self.handleError(e);
        }
    }
    customElements.define('vaultoro-directbuy', VaultoroDirectBuyElement);
</script>